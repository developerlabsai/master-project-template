# Component Architecture Guide

**Project:** [PROJECT_NAME]
**Stack:** Next.js 14 + Tailwind CSS + shadcn/ui
**Last Updated:** [DATE]

---

## Purpose

This document defines the component architecture, folder structure, and design patterns for frontend projects. Follow these patterns to maintain consistency and scalability.

---

## Folder Structure

```
src/
├── app/                           # Next.js App Router
│   ├── (auth)/                   # Route group: Authentication
│   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── register/
│   │   │   └── page.tsx
│   │   ├── forgot-password/
│   │   │   └── page.tsx
│   │   └── layout.tsx            # Auth layout (minimal header)
│   ├── (dashboard)/              # Route group: Authenticated pages
│   │   ├── dashboard/
│   │   │   └── page.tsx
│   │   ├── settings/
│   │   │   └── page.tsx
│   │   ├── profile/
│   │   │   └── page.tsx
│   │   └── layout.tsx            # Dashboard layout (sidebar, header)
│   ├── (marketing)/              # Route group: Public pages
│   │   ├── about/
│   │   │   └── page.tsx
│   │   ├── pricing/
│   │   │   └── page.tsx
│   │   ├── contact/
│   │   │   └── page.tsx
│   │   └── layout.tsx            # Marketing layout (navbar, footer)
│   ├── api/                      # API routes
│   │   ├── auth/
│   │   │   └── route.ts
│   │   └── users/
│   │       └── route.ts
│   ├── layout.tsx                # Root layout
│   ├── page.tsx                  # Home page
│   ├── loading.tsx               # Global loading state
│   ├── error.tsx                 # Global error boundary
│   ├── not-found.tsx             # 404 page
│   └── globals.css               # Global styles
│
├── components/
│   ├── ui/                       # shadcn/ui components (auto-generated)
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   ├── input.tsx
│   │   ├── dialog.tsx
│   │   └── ...
│   ├── layout/                   # Layout components
│   │   ├── header.tsx
│   │   ├── footer.tsx
│   │   ├── sidebar.tsx
│   │   ├── navbar.tsx
│   │   └── container.tsx
│   ├── forms/                    # Form components
│   │   ├── login-form.tsx
│   │   ├── register-form.tsx
│   │   ├── settings-form.tsx
│   │   └── contact-form.tsx
│   ├── features/                 # Feature-specific components
│   │   ├── auth/
│   │   │   ├── auth-guard.tsx
│   │   │   ├── login-button.tsx
│   │   │   └── logout-button.tsx
│   │   ├── dashboard/
│   │   │   ├── stats-card.tsx
│   │   │   ├── recent-activity.tsx
│   │   │   └── quick-actions.tsx
│   │   └── user/
│   │       ├── user-avatar.tsx
│   │       ├── user-menu.tsx
│   │       └── user-profile.tsx
│   ├── shared/                   # Shared/common components
│   │   ├── loading-spinner.tsx
│   │   ├── error-message.tsx
│   │   ├── empty-state.tsx
│   │   ├── page-header.tsx
│   │   └── confirmation-dialog.tsx
│   └── providers/                # Context providers
│       ├── theme-provider.tsx
│       ├── query-provider.tsx
│       └── auth-provider.tsx
│
├── lib/                          # Utility functions
│   ├── utils.ts                  # General utilities (cn, formatters)
│   ├── api.ts                    # API client
│   ├── validations.ts            # Zod schemas
│   ├── constants.ts              # App constants
│   └── helpers.ts                # Helper functions
│
├── hooks/                        # Custom React hooks
│   ├── use-user.ts               # User data hook
│   ├── use-auth.ts               # Authentication hook
│   ├── use-media-query.ts        # Responsive hook
│   ├── use-toast.ts              # Toast notifications
│   └── use-local-storage.ts      # Local storage hook
│
├── store/                        # State management (Zustand/Jotai)
│   ├── auth-store.ts             # Authentication state
│   ├── user-store.ts             # User state
│   └── ui-store.ts               # UI state (sidebar, modals)
│
├── types/                        # TypeScript types
│   ├── index.ts                  # Export all types
│   ├── user.ts                   # User types
│   ├── auth.ts                   # Auth types
│   └── api.ts                    # API response types
│
└── config/                       # Configuration
    ├── site.ts                   # Site metadata
    ├── navigation.ts             # Navigation config
    └── features.ts               # Feature flags
```

---

## Component Patterns

### 1. Atomic Design Principles

Organize components by complexity level:

**Atoms** (Basic UI elements)
- Located in: `components/ui/`
- Examples: Button, Input, Label, Badge
- Generated by shadcn/ui
- No business logic

**Molecules** (Simple combinations)
- Located in: `components/shared/`
- Examples: SearchBar, UserAvatar, StatCard
- Combine multiple atoms
- Minimal logic

**Organisms** (Complex components)
- Located in: `components/features/[feature]/`
- Examples: LoginForm, DataTable, DashboardStats
- Feature-specific
- Contains business logic

**Templates** (Page layouts)
- Located in: `components/layout/`
- Examples: DashboardLayout, MarketingLayout
- Define page structure
- Reusable across pages

**Pages** (Complete views)
- Located in: `app/*/page.tsx`
- Examples: Dashboard, Profile, Settings
- Combine organisms and templates
- Route-specific

---

### 2. Component Structure Template

```typescript
// components/features/dashboard/stats-card.tsx

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { cn } from "@/lib/utils"
import { LucideIcon } from "lucide-react"

// 1. Props interface
interface StatsCardProps {
  title: string
  value: string | number
  icon: LucideIcon
  trend?: {
    value: number
    isPositive: boolean
  }
  className?: string
}

// 2. Component definition
export function StatsCard({
  title,
  value,
  icon: Icon,
  trend,
  className,
}: StatsCardProps) {
  return (
    <Card className={cn("", className)}>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        <Icon className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {trend && (
          <p
            className={cn(
              "text-xs",
              trend.isPositive ? "text-green-600" : "text-red-600"
            )}
          >
            {trend.isPositive ? "+" : "-"}
            {Math.abs(trend.value)}% from last month
          </p>
        )}
      </CardContent>
    </Card>
  )
}

// 3. Optional: Display name for debugging
StatsCard.displayName = "StatsCard"
```

---

### 3. Server vs Client Components

**Server Components (Default)**

Use for:
- Data fetching
- Static content
- SEO-critical pages
- Reduce client bundle size

```typescript
// app/dashboard/page.tsx
import { StatsCard } from "@/components/features/dashboard/stats-card"

// Server component - no "use client"
export default async function DashboardPage() {
  // Fetch data directly
  const stats = await getStats()

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <StatsCard title="Total Users" value={stats.users} icon={Users} />
      <StatsCard title="Revenue" value={stats.revenue} icon={DollarSign} />
    </div>
  )
}
```

**Client Components**

Use for:
- Interactivity (onClick, onChange)
- Hooks (useState, useEffect)
- Browser APIs
- Third-party libraries with client-only code

```typescript
// components/theme-toggle.tsx
"use client"

import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const { setTheme, theme } = useTheme()

  return (
    <Button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
      Toggle Theme
    </Button>
  )
}
```

---

### 4. Form Components Pattern

**Using React Hook Form + Zod**

```typescript
// components/forms/contact-form.tsx
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "@/hooks/use-toast"

// 1. Define schema
const contactFormSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(10, "Message must be at least 10 characters"),
})

type ContactFormValues = z.infer<typeof contactFormSchema>

// 2. Component with form logic
export function ContactForm() {
  const form = useForm<ContactFormValues>({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      message: "",
    },
  })

  async function onSubmit(data: ContactFormValues) {
    try {
      // API call
      const response = await fetch("/api/contact", {
        method: "POST",
        body: JSON.stringify(data),
      })

      if (!response.ok) throw new Error("Failed to send message")

      toast({
        title: "Success",
        description: "Your message has been sent!",
      })

      form.reset()
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to send message. Please try again.",
        variant: "destructive",
      })
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="John Doe" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input
                  type="email"
                  placeholder="john@example.com"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Your message here..."
                  className="min-h-[120px]"
                  {...field}
                />
              </FormControl>
              <FormDescription>
                Please provide as much detail as possible
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" className="w-full" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? "Sending..." : "Send Message"}
        </Button>
      </form>
    </Form>
  )
}
```

---

### 5. Data Fetching Pattern

**Using TanStack Query**

```typescript
// hooks/use-users.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"

interface User {
  id: string
  name: string
  email: string
}

// Fetch all users
export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: async () => {
      const res = await fetch("/api/users")
      if (!res.ok) throw new Error("Failed to fetch users")
      return res.json() as Promise<User[]>
    },
  })
}

// Fetch single user
export function useUser(id: string) {
  return useQuery({
    queryKey: ["users", id],
    queryFn: async () => {
      const res = await fetch(`/api/users/${id}`)
      if (!res.ok) throw new Error("Failed to fetch user")
      return res.json() as Promise<User>
    },
    enabled: !!id, // Only fetch if id exists
  })
}

// Create user mutation
export function useCreateUser() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (newUser: Omit<User, "id">) => {
      const res = await fetch("/api/users", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newUser),
      })
      if (!res.ok) throw new Error("Failed to create user")
      return res.json()
    },
    onSuccess: () => {
      // Invalidate and refetch users list
      queryClient.invalidateQueries({ queryKey: ["users"] })
    },
  })
}

// Usage in component
function UsersList() {
  const { data: users, isLoading, error } = useUsers()

  if (isLoading) return <LoadingSpinner />
  if (error) return <ErrorMessage message={error.message} />

  return (
    <div>
      {users?.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

---

### 6. Layout Components

**Dashboard Layout Example**

```typescript
// components/layout/dashboard-layout.tsx
import { Header } from "./header"
import { Sidebar } from "./sidebar"

interface DashboardLayoutProps {
  children: React.ReactNode
}

export function DashboardLayout({ children }: DashboardLayoutProps) {
  return (
    <div className="min-h-screen">
      <Header />
      <div className="flex">
        <Sidebar />
        <main className="flex-1 p-8">
          {children}
        </main>
      </div>
    </div>
  )
}

// app/(dashboard)/layout.tsx
import { DashboardLayout } from "@/components/layout/dashboard-layout"

export default function Layout({ children }: { children: React.ReactNode }) {
  return <DashboardLayout>{children}</DashboardLayout>
}
```

---

### 7. Shared Component Examples

**Loading Spinner**

```typescript
// components/shared/loading-spinner.tsx
import { Loader2 } from "lucide-react"
import { cn } from "@/lib/utils"

interface LoadingSpinnerProps {
  className?: string
  size?: "sm" | "md" | "lg"
}

export function LoadingSpinner({ className, size = "md" }: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: "h-4 w-4",
    md: "h-8 w-8",
    lg: "h-12 w-12",
  }

  return (
    <div className="flex items-center justify-center">
      <Loader2 className={cn("animate-spin", sizeClasses[size], className)} />
    </div>
  )
}
```

**Error Message**

```typescript
// components/shared/error-message.tsx
import { AlertCircle } from "lucide-react"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"

interface ErrorMessageProps {
  title?: string
  message: string
}

export function ErrorMessage({
  title = "Error",
  message
}: ErrorMessageProps) {
  return (
    <Alert variant="destructive">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>{title}</AlertTitle>
      <AlertDescription>{message}</AlertDescription>
    </Alert>
  )
}
```

**Empty State**

```typescript
// components/shared/empty-state.tsx
import { LucideIcon } from "lucide-react"
import { Button } from "@/components/ui/button"

interface EmptyStateProps {
  icon: LucideIcon
  title: string
  description: string
  action?: {
    label: string
    onClick: () => void
  }
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action
}: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-8 text-center">
      <Icon className="h-12 w-12 text-muted-foreground mb-4" />
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      <p className="text-sm text-muted-foreground mb-4 max-w-sm">
        {description}
      </p>
      {action && (
        <Button onClick={action.onClick}>{action.label}</Button>
      )}
    </div>
  )
}
```

---

## Styling Conventions

### 1. Using Tailwind CSS

**Good Practices:**
```typescript
// ✅ Use semantic class grouping
<div className="flex items-center justify-between p-4 rounded-lg border bg-card">

// ✅ Use cn() utility for conditional classes
<div className={cn("p-4", isActive && "bg-primary", className)}>

// ✅ Extract repeated styles to components
<Card className="p-6">
```

**Avoid:**
```typescript
// ❌ Don't use inline styles
<div style={{ padding: "16px" }}>

// ❌ Don't create custom CSS files for simple styles
// Use Tailwind utilities instead

// ❌ Don't override shadcn/ui component styles unnecessarily
```

### 2. Component Variants with CVA

```typescript
// components/ui/badge.tsx
import { cva, type VariantProps } from "class-variance-authority"

const badgeVariants = cva(
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground",
        secondary: "bg-secondary text-secondary-foreground",
        destructive: "bg-destructive text-destructive-foreground",
        outline: "border border-input",
      },
      size: {
        sm: "px-2 py-0.5 text-xs",
        md: "px-2.5 py-0.5 text-sm",
        lg: "px-3 py-1 text-base",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
    },
  }
)

interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

export function Badge({ className, variant, size, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant, size }), className)} {...props} />
  )
}
```

---

## Best Practices

### 1. Component Naming

- **PascalCase** for components: `UserProfile.tsx`
- **kebab-case** for files: `user-profile.tsx`
- **Descriptive names**: `LoginForm` not `Form1`
- **Feature prefixes**: `DashboardStatsCard` for feature-specific components

### 2. Props

- Define explicit prop types with TypeScript
- Use optional props with `?` and defaults
- Destructure props for clarity
- Pass `className` for style customization

```typescript
interface ButtonProps {
  variant?: "primary" | "secondary"
  size?: "sm" | "md" | "lg"
  isLoading?: boolean
  onClick?: () => void
  className?: string
  children: React.ReactNode
}
```

### 3. State Management

**Use useState for:**
- Local component state
- Form inputs
- UI toggles (modals, dropdowns)

**Use Zustand/Jotai for:**
- Global app state
- User authentication
- Shopping cart
- UI preferences (theme, sidebar)

**Use TanStack Query for:**
- Server state
- API data
- Caching
- Background refetching

### 4. File Organization

- One component per file
- Co-locate related files
- Group by feature, not by type
- Keep flat structure when possible

```
✅ Good:
features/
  auth/
    login-form.tsx
    register-form.tsx
    auth-guard.tsx

❌ Avoid:
forms/
  login-form.tsx
  register-form.tsx
guards/
  auth-guard.tsx
```

### 5. Performance

- Use `React.memo()` for expensive renders
- Lazy load routes with `next/dynamic`
- Optimize images with `next/image`
- Debounce search inputs
- Virtualize long lists

```typescript
// Lazy load component
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("./heavy-component"), {
  loading: () => <LoadingSpinner />,
})

// Memoize expensive component
import { memo } from "react"

export const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // Complex rendering logic
})
```

### 6. Accessibility

- Use semantic HTML
- Add ARIA labels
- Keyboard navigation
- Focus management
- Color contrast

```typescript
<Button
  aria-label="Close dialog"
  aria-expanded={isOpen}
  onClick={handleClose}
>
  <X className="h-4 w-4" />
</Button>
```

---

## Component Checklist

Before finalizing a component:

- [ ] TypeScript types defined
- [ ] Props documented
- [ ] Responsive design (mobile, tablet, desktop)
- [ ] Dark mode support
- [ ] Accessibility (ARIA, keyboard)
- [ ] Loading states
- [ ] Error handling
- [ ] Performance optimized
- [ ] Reusable and composable
- [ ] Tests written (optional)

---

## Resources

- [Next.js App Router Docs](https://nextjs.org/docs/app)
- [shadcn/ui Components](https://ui.shadcn.com)
- [Tailwind CSS](https://tailwindcss.com)
- [Radix UI Primitives](https://www.radix-ui.com)
- [CVA Documentation](https://cva.style)

---

**Last Updated:** 2025-11-16
**Next Review:** 2026-02-16
